import axios from 'axios';
import * as numUtils from './num-utils';
import { convertJoulesToKwh } from './num-utils';

export interface DailyEnergyUsageProps {
  data: PVData[];
}

/**
 * gep: Generated Positive -- the energy generated by the solar panels
 * gen: Generated Negative -- the excess energy generated by the solar panels
 * h1d: heater-1 diverted -- the energy diverted from the panels to the immersion
 * h1b: heater-1 boost -- the energy being sent to the immersion due to boost (could come from gird)
 * imp: Imported -- the energy imported from the grid
 * exp: Exported -- the energy exported to the grid
 * pectn:Positive Energy CT-n -- the energy being consumed by the house
 * nectn: Negative Energy CT-n -- the excess energy being generated by the solar panels (how is this different to `gen`)
 * v1:Supply Voltage (centi-volts) -- the volatage of electricity being fed back to the grid. Should be between 240-250
 * frq:Supply Frequency (centi-Hertz) -- the AC frequency of the elecricity being fed back to the grid. Should be between 49-51Hz
*/
export interface EddiData {
  yr: number;
  mon: number;
  dom: number;
  dow: 'Sun' | 'Mon' | 'Tues' | 'Wed' | 'Thurs' | 'Fri' | 'Sat';
  hr?: number;
  min?: number;
  imp?: number;
  gep?: number;
  exp?: number;
  h1d?: number;
  h1b?: number;
  pect1?: number;
  pect2?: number;
  hsk?: number;
  v1?: number;
  frq?: number;
}

/**
 * As per the EDDI data format plus...
 * ctn:Current Transformer
 * hsk: Hestsink temperature
 */
export interface PVData {
  yr: number;
  mon: number;
  dom: number;
  dow: 'Sun' | 'Mon' | 'Tues' | 'Wed' | 'Thurs' | 'Fri' | 'Sat';
  hr: number;
  min: number;
  imp: number;
  gep: number;
  exp: number;
  h1d: number;
  h1b: number;
  conp: number;
  gepc: number;
}

const calculateEnergyConsumption = (
  importedJoules: number = 0,
  generatedJoules: number = 0,
  immersionDivertedJoules: number = 0,
  exportedJoules: number = 0): number => {

  return importedJoules + generatedJoules - immersionDivertedJoules - exportedJoules;
};

const calculateGreenEnergyPercentage = (importedJoules: number = 0, consumedJoules: number = 0): number => {
  if (importedJoules === 0) {
    return 100;
  }
  const greenJoules = consumedJoules - importedJoules;
  if (greenJoules <= 0) {
    return 0;
  }
  const percentage = Math.round((greenJoules / consumedJoules) * 100);
  return percentage;
};

export const getPVDataForDate = async (formattedTargetDate: string): Promise<PVData[]> => {
  console.log(`Retrieving per minute data for ${formattedTargetDate}`);
  // const url = `http://192.168.68.143:3001/hour-data?date=${formattedTargetDate}`;
  const url = `http://localhost:3001/minute-data?date=${formattedTargetDate}`;
  try {
    const response = await axios.get(url);
    const data = await Promise.resolve(response.data.U21494842 as EddiData[]);
    return data.map((item: EddiData) => {
      const conp = calculateEnergyConsumption(item.imp, item.gep, item.h1d, item.exp);
      const gepc = calculateGreenEnergyPercentage(item.imp, conp);
      return {
        // set some defaults first
        hr: 0,
        min: 0,
        imp: 0,
        gep: 0,
        exp: 0,
        h1d: 0,
        h1b: 0,
        conp,
        gepc,
        // then spread the actual eddit data over the top which may be missing some of the above props
        ...item,
      };
    });
  } catch (error) {
    console.log('Error retrieving remote data', error);
    document.body.style.cursor = 'auto';
    return [];
  };
};

export const convertMinuteDataToHourlyData = (minuteData: PVData[] = []): PVData[] => {
  const hourlyTotals: { [hour: number]: PVData } = {};

  for (const minuteItem of minuteData) {
    const { yr, mon, dom, dow, hr = 0, min = 0, imp = 0, gep = 0, exp = 0, h1d = 0, h1b = 0, conp = 0, gepc = 0 } = minuteItem;
    hourlyTotals[hr] ??= { yr, mon, dom, dow, hr, min, imp: 0, gep: 0, exp: 0, h1d: 0, h1b: 0, conp: 0, gepc: 0 };
    hourlyTotals[hr].imp += convertJoulesToKwh(imp);
    hourlyTotals[hr].gep += convertJoulesToKwh(gep);
    hourlyTotals[hr].exp += convertJoulesToKwh(exp);
    hourlyTotals[hr].h1d += convertJoulesToKwh(h1d);
    hourlyTotals[hr].h1b += convertJoulesToKwh(h1b);
    hourlyTotals[hr].conp += convertJoulesToKwh(conp);
  }
  // calculate the green energy percentyage for each half hour
  for (const halfHour in hourlyTotals) {
    const { imp, conp } = hourlyTotals[halfHour];
    hourlyTotals[halfHour].gepc = calculateGreenEnergyPercentage(imp, conp);
  }
  return Object.values(hourlyTotals);
};

export const convertMinuteDataToHalfHourlyData = (minuteData: PVData[] = []): PVData[] => {
  const halfHourlyTotals: { [halfHour: string]: PVData } = {};

  for (const minuteItem of minuteData) {
    const { yr, mon, dom, dow, hr = 0, min = 0, imp = 0, gep = 0, exp = 0, h1d = 0, h1b = 0, conp = 0, gepc = 0 } = minuteItem;
    const halfHour = `${hr}:${min < 30 ? '00' : '30'}`;
    halfHourlyTotals[halfHour] ??= { yr, mon, dom, dow, hr: parseInt(halfHour.split(':')[0]), min: parseInt(halfHour.split(':')[1]), imp: 0, gep: 0, exp: 0, h1d: 0, h1b: 0, conp: 0, gepc: 0 };
    halfHourlyTotals[halfHour].imp += convertJoulesToKwh(imp);
    halfHourlyTotals[halfHour].gep += convertJoulesToKwh(gep);
    halfHourlyTotals[halfHour].exp += convertJoulesToKwh(exp);
    halfHourlyTotals[halfHour].h1d += convertJoulesToKwh(h1d);
    halfHourlyTotals[halfHour].h1b += convertJoulesToKwh(h1b);
    halfHourlyTotals[halfHour].conp += convertJoulesToKwh(conp);
    halfHourlyTotals[halfHour].gepc += gepc;
  }
  // calculate the green energy percentyage for each half hour
  for (const halfHour in halfHourlyTotals) {
    const { imp, conp } = halfHourlyTotals[halfHour];
    halfHourlyTotals[halfHour].gepc = calculateGreenEnergyPercentage(imp, conp);
  }
  return Object.values(halfHourlyTotals);
};